diff -Npurd '--exclude=.git*' '--exclude=*.lo' '--exclude=*.lai'
'--exclude=*.la' '--exclude=*.mak' '--exclude=*.orig'
'--exclude=*make.bat--exclude=ChangeLog' '--exclude=*.P*' '--exclude=NEWS'
'--exclude=PORTS' '--exclude=README' '--exclude=libtool' '--exclude=*.spec'
'--exclude=*.service' '--exclude=*.nsi' '--exclude=*.license'
'--exclude=*.init' '--exclude=*.in' '--exclude=*.*-sample' '--exclude=*.cnf'
'--exclude=*.bat' '--exclude=*.pl' '--exclude=*.html' '--exclude=TODO'
'--exclude=stunnel3*' '--exclude=CREDITS' '--exclude=*INSTALL*'
'--exclude=*COPY*' '--exclude=*ac*' '--exclude=AUTHORS' '--exclude=BUGS'
'--exclude=*.sh' '--exclude=staging_dir' '--exclude=*.log*' '--exclude=auto'
'--exclude=dl' '--exclude=*.conf' '--exclude=.config*' '--exclude=feeds'
'--exclude=doc' '--exclude=*.o' '--exclude=*tmp*' '--exclude=Makefile.*'
'--exclude=m4' '--exclude=config*' /home/test/stunnel-5.10/src/client.c ./src/client.c
--- ./stunnel-5.10/src/client.c	2015-06-01 12:06:51.613961204 -0700
+++ ./src/client.c	2015-05-29 16:14:18.834182273 -0700
@@ -67,6 +67,8 @@ NOEXPORT void print_bound_address(CLI *)
 NOEXPORT void reset(int, char *);
 
 /* allocate local data structure for the new thread */
+static char NETOPEER_AGENT[]="/usr/local/bin/netopeer-agent";
+static char NETOPEER_ARGS[]="netopeer-agent";
 CLI *alloc_client_session(SERVICE_OPTIONS *opt, int rfd, int wfd) {
     CLI *c;
 
@@ -148,7 +150,8 @@ NOEXPORT void client_run(CLI *c) {
     if(c->opt->option.client) {
         c->sock_rfd=&(c->local_rfd);
         c->sock_wfd=&(c->local_wfd);
-        c->ssl_rfd=c->ssl_wfd=&(c->remote_fd);
+        c->ssl_rfd = c->ssl_wfd = & (usc_secure_ch->remote_fd);
+	    c->ssl = usc_secure_ch->ssl;
     } else {
         c->sock_rfd=c->sock_wfd=&(c->remote_fd);
         c->ssl_rfd=&(c->local_rfd);
@@ -236,14 +239,16 @@ NOEXPORT void client_run(CLI *c) {
 NOEXPORT void client_try(CLI *c) {
     local_start(c);
     protocol(c, c->opt, PROTOCOL_EARLY);
-    if(c->opt->option.connect_before_ssl) {
-        remote_start(c);
-        protocol(c, c->opt, PROTOCOL_MIDDLE);
-        ssl_start(c);
-    } else {
-        ssl_start(c);
-        protocol(c, c->opt, PROTOCOL_MIDDLE);
-        remote_start(c);
+    if(!c->opt->option.client) {
+	    if(c->opt->option.connect_before_ssl) {
+            remote_start(c);
+            protocol(c, c->opt, PROTOCOL_MIDDLE);
+            ssl_start(c);
+    	} else {
+            ssl_start(c);
+            protocol(c, c->opt, PROTOCOL_MIDDLE);
+            remote_start(c);
+    	}
     }
     protocol(c, c->opt, PROTOCOL_LATE);
     transfer(c);
@@ -333,16 +338,19 @@ NOEXPORT void remote_start(CLI *c) {
         /* try remote first for exec+connect targets */
         c->remote_fd.fd=connect_remote(c);
     } else if(c->opt->option.program) { /* exec+connect uses local fd */
+		if(c->opt->option.client)
         c->remote_fd.fd=connect_local(c);
     } else {
         s_log(LOG_ERR, "INTERNAL ERROR: No target for remote socket");
         longjmp(c->err, 1);
     }
 
+	if(c->opt->option.client) {
     c->remote_fd.is_socket=1; /* always! */
     s_log(LOG_DEBUG, "Remote socket (FD=%d) initialized", c->remote_fd.fd);
     if(set_socket_options(c->remote_fd.fd, 2))
         s_log(LOG_WARNING, "Failed to set remote socket options");
+    }
 }
 
 NOEXPORT void ssl_start(CLI *c) {
@@ -514,19 +522,34 @@ NOEXPORT void transfer(CLI *c) {
     ssize_t num;
     int err;
     /* logical channels (not file descriptors!) open for read or write */
-    int sock_open_rd=1, sock_open_wr=1;
+    int usc_size;
+    char *tmp_ptr;
+    int sock_open_rd = 0, sock_open_wr = 0;
     /* awaited conditions on SSL file descriptors */
     int shutdown_wants_read=0, shutdown_wants_write=0;
     int read_wants_read=0, read_wants_write=0;
     int write_wants_read=0, write_wants_write=0;
     /* actual conditions on file descriptors */
     int sock_can_rd, sock_can_wr, ssl_can_rd, ssl_can_wr;
+    usc_header *read_usc;
+    usc_header write_usc;
+    int rd_sock_closed = 0;
+    call_home_mode = 0;
 #ifdef USE_WIN32
     unsigned long bytes;
 #else
     int bytes;
 #endif
 
+    if(c->opt->option.client)
+        sock_open_rd = 1, sock_open_wr = 1;
+    if (!c->opt->option.client && c->remote_fd.fd) {
+        c->remote_fd.is_socket = 1; /* always! */;
+        c->sock_rfd->fd = c->sock_wfd->fd = c->remote_fd.fd;
+        sock_open_rd = sock_open_wr = 1;
+        rd_sock_closed = 0;
+        call_home_mode = 1;
+    }   
     c->sock_ptr=c->ssl_ptr=0;
 
     do { /* main loop of client data transfer */
@@ -653,7 +676,7 @@ NOEXPORT void transfer(CLI *c) {
         }
 
         /****************************** read from socket */
-        if(sock_open_rd && sock_can_rd) {
+        if (sock_open_rd && sock_can_rd && !rd_sock_closed) {
             num=readsocket(c->sock_rfd->fd,
                 c->sock_buff+c->sock_ptr, BUFFSIZE-c->sock_ptr);
             switch(num) {
@@ -664,11 +687,15 @@ NOEXPORT void transfer(CLI *c) {
                 break;
             case 0: /* close */
                 s_log(LOG_INFO, "Read socket closed (readsocket)");
-                sock_open_rd=0;
+                rd_sock_closed = 1;
+				if(!c->opt->option.client)
+	                c->remote_fd.fd = -1;
                 break;
             default:
                 c->sock_ptr+=(size_t)num;
                 watchdog=0; /* reset watchdog */
+				if(!c->opt->option.client)
+                    rd_sock_closed = 0;
             }
         }
 
@@ -678,6 +705,20 @@ NOEXPORT void transfer(CLI *c) {
             && c->ssl_ptr<BUFFSIZE && !read_wants_write;
         write_wants_write|=!(SSL_get_shutdown(c->ssl)&SSL_SENT_SHUTDOWN)
             && c->sock_ptr && !write_wants_read;
+        if (!memcmp(c->sock_buff, NC_V10_START_MSG, 5) || !memcmp(c->sock_buff,NC_V11_START_MSG, 2)) {
+            uint8_t *ptr =  c->sock_buff;
+            add_usc_header(&write_usc, c, c->sock_ptr, USC_OP_DATA, USC_SEC_TRANS_TLS); 
+            s_log (LOG_DEBUG, "Adding version:%d usc_op:%d app_id:%d session:%d sec:%d payload:%d \n",
+                    write_usc.usc_version,
+                    write_usc.usc_op,
+                    ntohs (write_usc.app_id),
+                    ntohs (write_usc.app_session),
+                    write_usc.sec_trans,
+                    ntohs (write_usc.payload_length));                    
+            ptr = adjust_usc_header_payload(&ptr, c->sock_ptr);
+            memcpy (c->sock_buff, &write_usc, sizeof(usc_header));
+            c->sock_ptr += sizeof(usc_header);
+        }
 
         /****************************** write to SSL */
         if((write_wants_read && ssl_can_rd) ||
@@ -793,6 +834,61 @@ NOEXPORT void transfer(CLI *c) {
             }
         }
 
+        /* checking for USC header for version */
+        read_usc = c->ssl_buff;
+        if ((read_usc->usc_version == USC_VERSION) && num > sizeof (usc_header)) {   
+            int fd; 
+            usc_size = sizeof (usc_header);        
+            tmp_ptr = c->ssl_buff;
+            tmp_ptr += usc_size;
+            c->ssl_ptr -= usc_size;        
+            if(ntohs(read_usc->app_id) != TLS_NETCONF_PORT) {
+                   uint8_t err_buf[8];
+                   int8_t *ptr = err_buf;
+                   prepare_error_handling(ptr,read_usc->app_id, read_usc->app_session, get_last_socket_error()); 
+                   s_log (LOG_DEBUG, "%s: Server is not Reachable, sending Error USC Message ", __func__);
+                   num = SSL_write (c->ssl, err_buf, sizeof (usc_header)); 
+            } else {
+                if (c->remote_fd.fd == -1) {               
+                    fd = connect_local (c);  
+                    if(fd < 0) {
+                        uint8_t err_buf[8];
+                        int8_t *ptr = err_buf;
+                        prepare_error_handling(ptr,read_usc->app_id, read_usc->app_session, get_last_socket_error()); 
+                        s_log (LOG_DEBUG, "%s: Server is not Reachable, sending Error USC Message ", __func__);
+                        num = SSL_write (c->ssl, err_buf, sizeof (usc_header)); 
+                    } else {  
+    	                c->remote_fd.fd = fd;
+                        c->remote_fd.is_socket = 1; /* always! */
+                        s_log (LOG_DEBUG, "%s: Remote socket (FD=%d) initialized", __func__,  c->remote_fd.fd);
+                        if (set_socket_options (c->remote_fd.fd, 2 ))
+                            s_log (LOG_WARNING, "%s: Failed to set remote socket options", __func__);
+                        c->sock_rfd->fd = c->sock_wfd->fd = c->remote_fd.fd;
+                        sock_open_rd = sock_open_wr = 1;
+                        rd_sock_closed = 0;
+                        c->usc.usc_version = read_usc->usc_version;
+                        c->usc.usc_op = read_usc->usc_op;
+                        c->usc.app_id = ntohs (read_usc->app_id);
+                        c->usc.app_session = ntohs (read_usc->app_session);
+                        c->usc.sec_trans = read_usc->sec_trans;
+                        c->usc.payload_length = ntohs (read_usc->payload_length);
+                        s_log ( LOG_DEBUG, 
+                            "Assigned version:%d usc_op:%d app_id:%d session:%d sec:%d payload:%d \n",
+                            c->usc.usc_version,
+                            c->usc.usc_op,
+                            c->usc.app_id,
+                            c->usc.app_session,
+                            c->usc.sec_trans,
+                            c->usc.payload_length);
+                    }
+    	        } else {
+                     if(parse_usc_header(c->ssl_buff, c)) {
+                         ;       
+                     }
+                }    
+             }
+             memmove (c->ssl_buff, tmp_ptr, c->ssl_ptr);
+        }
         /****************************** check for hangup conditions */
         /* http://marc.info/?l=linux-man&m=128002066306087 */
         /* readsocket() must be the last sock_rfd operation before FIONREAD */
@@ -852,7 +948,8 @@ NOEXPORT void transfer(CLI *c) {
                 !c->sock_ptr && !write_wants_write) {
             if(SSL_version(c->ssl)!=SSL2_VERSION) {
                 s_log(LOG_DEBUG, "Sending close_notify alert");
-                shutdown_wants_write=1;
+				if(!c->opt->option.client)
+                    shutdown_wants_write=1;
             } else { /* no alerts in SSLv2, including the close_notify alert */
                 s_log(LOG_DEBUG, "Closing SSLv2 socket");
                 if(c->ssl_rfd->is_socket)
@@ -863,7 +960,7 @@ NOEXPORT void transfer(CLI *c) {
                 SSL_set_shutdown(c->ssl, SSL_SENT_SHUTDOWN|SSL_RECEIVED_SHUTDOWN);
             }
         }
-
+#if 0 
         /****************************** check watchdog */
         if(++watchdog>100) { /* loop executes without transferring any data */
             s_log(LOG_ERR,
@@ -893,7 +990,7 @@ NOEXPORT void transfer(CLI *c) {
                 "ssl input buffer: %ld byte(s)", c->sock_ptr, c->ssl_ptr);
             longjmp(c->err, 1);
         }
-
+#endif
     } while(sock_open_wr || !(SSL_get_shutdown(c->ssl)&SSL_SENT_SHUTDOWN) ||
         shutdown_wants_read || shutdown_wants_write);
 }
@@ -1080,6 +1177,11 @@ NOEXPORT int connect_local(CLI *c) { /*
     char *name, host[40], port[6];
     int fd[2], pid;
     X509 *peer;
+    unsigned char *digest;
+    unsigned int dig_len, i;
+    STACK_OF (GENERAL_NAME) *san_names;
+    GENERAL_NAME *san_name;
+    ASN1_OCTET_STRING *ip;
 #ifdef HAVE_PTHREAD_SIGMASK
     sigset_t newmask;
 #endif
@@ -1139,6 +1241,101 @@ NOEXPORT int connect_local(CLI *c) { /*
                 putenv(str_printf("SSL_CLIENT_DN=%s", name));
                 name=X509_NAME2text(X509_get_issuer_name(peer));
                 putenv(str_printf("SSL_CLIENT_I_DN=%s", name));
+                dig_len = 64;
+                digest = malloc ( dig_len );
+                X509_digest ( peer, EVP_md5(), digest, &dig_len );
+                name = str_printf ( "SSL_CLIENT_MD5=%02x:%02x:%02x:%02x", digest[0], digest[1], digest[2], digest[3] );
+                for ( i = 4; i < dig_len; i += 4 ) {
+                    name = str_printf ( "%s:%02x:%02x:%02x:%02x", name, digest[i], digest[i + 1], digest[i + 2], digest[i + 3] );
+                }
+                putenv ( name );
+
+                X509_digest ( peer, EVP_sha1(), digest, &dig_len );
+                name = str_printf ( "SSL_CLIENT_SHA1=%02x:%02x:%02x:%02x", digest[0], digest[1], digest[2], digest[3] );
+
+                for ( i = 4; i < dig_len; i += 4 ) {
+                    name = str_printf ( "%s:%02x:%02x:%02x:%02x", name, digest[i], digest[i + 1], digest[i + 2], digest[i + 3] );
+                }
+
+                putenv ( name );
+
+                X509_digest ( peer, EVP_sha224(), digest, &dig_len );
+                name = str_printf ( "SSL_CLIENT_SHA224=%02x:%02x:%02x:%02x", digest[0], digest[1], digest[2], digest[3] );
+
+                for ( i = 4; i < dig_len; i += 4 ) {
+                    name = str_printf ( "%s:%02x:%02x:%02x:%02x", name, digest[i], digest[i + 1], digest[i + 2], digest[i + 3] );
+                }
+
+                putenv ( name );
+
+                X509_digest ( peer, EVP_sha256(), digest, &dig_len );
+                name = str_printf ( "SSL_CLIENT_SHA256=%02x:%02x:%02x:%02x", digest[0], digest[1], digest[2], digest[3] );
+
+                for ( i = 4; i < dig_len; i += 4 ) {
+                    name = str_printf ( "%s:%02x:%02x:%02x:%02x", name, digest[i], digest[i + 1], digest[i + 2], digest[i + 3] );
+                }
+
+                putenv ( name );
+
+                X509_digest ( peer, EVP_sha384(), digest, &dig_len );
+                name = str_printf ( "SSL_CLIENT_SHA384=%02x:%02x:%02x:%02x", digest[0], digest[1], digest[2], digest[3] );
+
+                for ( i = 4; i < dig_len; i += 4 ) {
+                    name = str_printf ( "%s:%02x:%02x:%02x:%02x", name, digest[i], digest[i + 1], digest[i + 2], digest[i + 3] );
+                }
+
+                putenv ( name );
+
+                X509_digest ( peer, EVP_sha512(), digest, &dig_len );
+                name = str_printf ( "SSL_CLIENT_SHA512=%02x:%02x:%02x:%02x", digest[0], digest[1], digest[2], digest[3] );
+
+                for ( i = 4; i < dig_len; i += 4 ) {
+                    name = str_printf ( "%s:%02x:%02x:%02x:%02x", name, digest[i], digest[i + 1], digest[i + 2], digest[i + 3] );
+                }
+
+                putenv ( name );
+                free ( digest );
+
+                /* retrieve subjectAltName's rfc822Name (email), dNSName and iPAddress values */
+                san_names = X509_get_ext_d2i ( peer, NID_subject_alt_name, NULL, NULL );
+
+                if ( san_names != NULL ) {
+                    name = str_printf ( "SSL_CLIENT_SAN=" );
+
+                    for ( i = 0; i < ( unsigned ) sk_GENERAL_NAME_num ( san_names ); ++i ) {
+                        san_name = sk_GENERAL_NAME_value ( san_names, i );
+
+                        if ( san_name->type == GEN_EMAIL || san_name->type == GEN_DNS || san_name->type == GEN_IPADD ) {
+                            if ( san_name->type == GEN_EMAIL ) {
+                                name = str_printf ( "%s/EMAIL=%s", name, ( char* ) ASN1_STRING_data ( san_name->d.rfc822Name ) );
+                            }
+
+                            if ( san_name->type == GEN_DNS ) {
+                                name = str_printf ( "%s/DNS=%s", name, ( char* ) ASN1_STRING_data ( san_name->d.dNSName ) );
+                            }
+
+                            if ( san_name->type == GEN_IPADD ) {
+                                ip = san_name->d.iPAddress;
+
+                                if ( ip->length == 4 ) {
+                                    name = str_printf ( "%s/IP=%d.%d.%d.%d", name, ip->data[0], ip->data[1], ip->data[2], ip->data[3] );
+                                } else if ( ip->length == 16 ) {
+                                    name = str_printf ( "%s/IP=%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
+                                                        name, ip->data[0], ip->data[1], ip->data[2], ip->data[3], ip->data[4], ip->data[5],
+                                                        ip->data[6], ip->data[7], ip->data[8], ip->data[9], ip->data[10], ip->data[11], ip->data[12],
+                                                        ip->data[13], ip->data[14], ip->data[15] );
+                                }
+                            }
+                        }
+                    }
+
+                    if ( strlen ( name ) > 15 ) {
+                        putenv ( name );
+                    }
+
+                    sk_GENERAL_NAME_pop_free ( san_names, GENERAL_NAME_free );
+                }
+
                 X509_free(peer);
             }
         }
@@ -1153,6 +1350,8 @@ NOEXPORT int connect_local(CLI *c) { /*
         signal(SIGTERM, SIG_DFL);
         signal(SIGQUIT, SIG_DFL);
         signal(SIGINT, SIG_DFL);
+        if(!c->opt->execname) 
+           c->opt->execname = NETOPEER_AGENT;
         execvp(c->opt->execname, c->opt->execargs);
         ioerror(c->opt->execname); /* execvp failed */
         _exit(1);
Binary files /home/test/stunnel-5.10/src/.libs/libstunnel.so and ./src/.libs/libstunnel.so differ
diff -Npurd '--exclude=.git*' '--exclude=*.lo' '--exclude=*.lai'
'--exclude=*.la' '--exclude=*.mak' '--exclude=*.orig'
'--exclude=*make.bat--exclude=ChangeLog' '--exclude=*.P*' '--exclude=NEWS'
'--exclude=PORTS' '--exclude=README' '--exclude=libtool' '--exclude=*.spec'
'--exclude=*.service' '--exclude=*.nsi' '--exclude=*.license'
'--exclude=*.init' '--exclude=*.in' '--exclude=*.*-sample' '--exclude=*.cnf'
'--exclude=*.bat' '--exclude=*.pl' '--exclude=*.html' '--exclude=TODO'
'--exclude=stunnel3*' '--exclude=CREDITS' '--exclude=*INSTALL*'
'--exclude=*COPY*' '--exclude=*ac*' '--exclude=AUTHORS' '--exclude=BUGS'
'--exclude=*.sh' '--exclude=staging_dir' '--exclude=*.log*' '--exclude=auto'
'--exclude=dl' '--exclude=*.conf' '--exclude=.config*' '--exclude=feeds'
'--exclude=doc' '--exclude=*.o' '--exclude=*tmp*' '--exclude=Makefile.*'
'--exclude=m4' '--exclude=config*' /home/test/stunnel-5.10/src/Makefile ./src/Makefile
--- /home/test/stunnel-5.10/src/Makefile	2015-06-01 12:06:51.617961204 -0700
+++ ./src/Makefile	2015-06-01 12:18:59.266580807 -0700
@@ -152,7 +152,7 @@ am__objects_3 = stunnel-str.$(OBJEXT) st
 	stunnel-network.$(OBJEXT) stunnel-resolver.$(OBJEXT) \
 	stunnel-ssl.$(OBJEXT) stunnel-ctx.$(OBJEXT) \
 	stunnel-verify.$(OBJEXT) stunnel-sthreads.$(OBJEXT) \
-	stunnel-fd.$(OBJEXT) stunnel-stunnel.$(OBJEXT)
+	stunnel-fd.$(OBJEXT) stunnel-stunnel.$(OBJEXT) usc.$(OBJEXT)
 am__objects_4 = stunnel-pty.$(OBJEXT) stunnel-libwrap.$(OBJEXT) \
 	stunnel-ui_unix.$(OBJEXT)
 am_stunnel_OBJECTS = $(am__objects_2) $(am__objects_3) \
@@ -166,7 +166,7 @@ am__objects_5 = str.$(OBJEXT) file.$(OBJ
 	log.$(OBJEXT) options.$(OBJEXT) protocol.$(OBJEXT) \
 	network.$(OBJEXT) resolver.$(OBJEXT) ssl.$(OBJEXT) \
 	ctx.$(OBJEXT) verify.$(OBJEXT) sthreads.$(OBJEXT) fd.$(OBJEXT) \
-	stunnel.$(OBJEXT)
+	stunnel.$(OBJEXT) usc.$(OBJEXT)
 am__objects_6 = ui_win_gui.$(OBJEXT)
 am_stunnel_exe_OBJECTS = $(am__objects_2) $(am__objects_5) \
 	$(am__objects_6)
@@ -242,17 +242,17 @@ am__define_uniq_tagged_files = \
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = ${SHELL} /home/test/stunnel-5.10/auto/missing aclocal-1.14
+ACLOCAL = ${SHELL} ./auto/missing aclocal-1.14
 AMTAR = $${TAR-tar}
 AM_DEFAULT_VERBOSITY = 1
 AR = ar
-AUTOCONF = ${SHELL} /home/test/stunnel-5.10/auto/missing autoconf
-AUTOHEADER = ${SHELL} /home/test/stunnel-5.10/auto/missing autoheader
-AUTOMAKE = ${SHELL} /home/test/stunnel-5.10/auto/missing automake-1.14
+AUTOCONF = ${SHELL} ./auto/missing autoconf
+AUTOHEADER = ${SHELL} ./auto/missing autoheader
+AUTOMAKE = ${SHELL} ./auto/missing automake-1.14
 AWK = gawk
 CC = gcc
 CCDEPMODE = depmode=gcc3
-CFLAGS = -g -O2 -pthread -Wall -Wextra -Wformat=2 -Wconversion -Wno-long-long -Wno-deprecated-declarations -fstack-protector -fPIE -D_FORTIFY_SOURCE=2
+CFLAGS = -g3 -gdwarf-2 -O0 -pthread -Wall -Wextra -Wformat=2 -Wconversion -Wno-long-long -Wno-pointer-sign -Wno-deprecated-declarations -Wno-sign-conversion -fstack-protector -fPIE -D_FORTIFY_SOURCE=2
 CPP = gcc -E
 CPPFLAGS = 
 CYGPATH_W = echo
@@ -283,7 +283,7 @@ LIBTOOL_DEPS = auto/ltmain.sh
 LIPO = 
 LN_S = ln -s
 LTLIBOBJS = 
-MAKEINFO = ${SHELL} /home/test/stunnel-5.10/auto/missing makeinfo
+MAKEINFO = ${SHELL} ./auto/missing makeinfo
 MANIFEST_TOOL = :
 MKDIR_P = /bin/mkdir -p
 NM = /usr/bin/nm -B
@@ -295,7 +295,7 @@ OTOOL64 =
 PACKAGE = stunnel
 PACKAGE_BUGREPORT = 
 PACKAGE_NAME = stunnel
-PACKAGE_STRING = stunnel 5.10
+PACKAGE_STRING = stunnel 
 PACKAGE_TARNAME = stunnel
 PACKAGE_URL = 
 PACKAGE_VERSION = 5.10
@@ -311,10 +311,10 @@ SHELL = /bin/bash
 SSLDIR = /usr/local/ssl
 STRIP = strip
 VERSION = 5.10
-abs_builddir = /home/test/stunnel-5.10/src
-abs_srcdir = /home/test/stunnel-5.10/src
-abs_top_builddir = /home/test/stunnel-5.10
-abs_top_srcdir = /home/test/stunnel-5.10
+abs_builddir = ./src
+abs_srcdir = ./src
+abs_top_builddir = .
+abs_top_srcdir = .
 ac_ct_AR = ar
 ac_ct_CC = gcc
 ac_ct_DUMPBIN = 
@@ -344,7 +344,7 @@ host_vendor = unknown
 htmldir = ${docdir}
 includedir = ${prefix}/include
 infodir = ${datarootdir}/info
-install_sh = ${SHELL} /home/test/stunnel-5.10/auto/install-sh
+install_sh = ${SHELL} ./agent/auto/install-sh
 libdir = ${exec_prefix}/lib
 libexecdir = ${exec_prefix}/libexec
 localedir = ${datarootdir}/locale
@@ -400,9 +400,10 @@ tstunnel_exe_SOURCES = $(common_headers)
 
 # OPENSSLDIR = /usr/src/openssl-0.9.8u-fips
 # WINCPPFLAGS = -I$(OPENSSLDIR)/inc32
-OPENSSLDIR = /usr/src/openssl-1.0.1l-i686
+#OPENSSLDIR = /usr/src/openssl-1.0.1l-i686
+OPENSSLDIR =../../openssl 
 WINCPPFLAGS = -I$(OPENSSLDIR)/include
-WINCFLAGS = -mthreads -fstack-protector -O2 -Wall -Wextra -Wpedantic \
+WINCFLAGS = -mthreads -fstack-protector -O0 -Wall -Wextra -Wpedantic \
 	-Wformat=2 -Wconversion -Wno-long-long -D_FORTIFY_SOURCE=2 \
 	-DUNICODE -D_UNICODE
 WINLDFLAGS = -mthreads -fstack-protector -s
@@ -433,7 +434,7 @@ $(srcdir)/Makefile.in:  $(srcdir)/Makefi
 	$(am__cd) $(top_srcdir) && \
 	  $(AUTOMAKE) --gnu src/Makefile
 .PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+Makefile: 
 	@case '$?' in \
 	  *config.status*) \
 	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
@@ -451,22 +452,10 @@ $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(am__aclocal_m4_deps):
 
-config.h: stamp-h1
-	@test -f $@ || rm -f stamp-h1
-	@test -f $@ || $(MAKE) $(AM_MAKEFLAGS) stamp-h1
-
-stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
-	@rm -f stamp-h1
-	cd $(top_builddir) && $(SHELL) ./config.status src/config.h
-$(srcdir)/config.h.in:  $(am__configure_deps) 
-	($(am__cd) $(top_srcdir) && $(AUTOHEADER))
-	rm -f stamp-h1
-	touch $@
 
 distclean-hdr:
 	-rm -f config.h stamp-h1
 stunnel3: $(top_builddir)/config.status $(srcdir)/stunnel3.in
-	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@
 
 install-pkglibLTLIBRARIES: $(pkglib_LTLIBRARIES)
 	@$(NORMAL_INSTALL)
@@ -894,6 +883,22 @@ stunnel-ui_unix.obj: ui_unix.c
 #	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
 #	$(AM_V_CC_no)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(stunnel_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o stunnel-ui_unix.obj `if test -f 'ui_unix.c'; then $(CYGPATH_W) 'ui_unix.c'; else $(CYGPATH_W) '$(srcdir)/ui_unix.c'; fi`
 
+usc.o: usc.c
+	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(stunnel_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT usc.o -MD -MP -MF $(DEPDIR)/usc.Tpo -c -o usc.o `test -f 'usc.c' || echo '$(srcdir)/'`usc.c
+	$(AM_V_at)$(am__mv) $(DEPDIR)/usc.Tpo $(DEPDIR)/usc.Po
+#	$(AM_V_CC)source='ui_unix.c' object='stunnel-ui_unix.o' libtool=no \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(stunnel_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o stunnel-ui_unix.o `test -f 'ui_unix.c' || echo '$(srcdir)/'`ui_unix.c
+
+
+usc.obj: usc.c
+	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(stunnel_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT usc.obj -MD -MP -MF $(DEPDIR)/usc.Tpo -c -o usc.obj `if test -f 'usc.c'; then $(CYGPATH_W) 'usc.c'; else $(CYGPATH_W) '$(srcdir)/usc.c'; fi`
+	$(AM_V_at)$(am__mv) $(DEPDIR)/usc.Tpo $(DEPDIR)/usc.Po
+#	$(AM_V_CC)source='ui_unix.c' object='stunnel-ui_unix.obj' libtool=no \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(AM_V_CC_no)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(stunnel_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o stunnel-ui_unix.obj `if test -f 'ui_unix.c'; then $(CYGPATH_W) 'ui_unix.c'; else $(CYGPATH_W) '$(srcdir)/ui_unix.c'; fi`
+
+
 mostlyclean-libtool:
 	-rm -f *.lo
 
diff -Npurd '--exclude=.git*' '--exclude=*.lo' '--exclude=*.lai' '--exclude=*.la' '--exclude=*.mak' '--exclude=*.orig' '--exclude=*make.bat--exclude=ChangeLog' '--exclude=*.P*' '--exclude=NEWS' '--exclude=PORTS' '--exclude=README' '--exclude=libtool' '--exclude=*.spec' '--exclude=*.service' '--exclude=*.nsi' '--exclude=*.license' '--exclude=*.init' '--exclude=*.in' '--exclude=*.*-sample' '--exclude=*.cnf' '--exclude=*.bat' '--exclude=*.pl' '--exclude=*.html' '--exclude=TODO' '--exclude=stunnel3*' '--exclude=CREDITS' '--exclude=*INSTALL*' '--exclude=*COPY*' '--exclude=*ac*' '--exclude=AUTHORS' '--exclude=BUGS' '--exclude=*.sh' '--exclude=staging_dir' '--exclude=*.log*' '--exclude=auto' '--exclude=dl' '--exclude=*.conf' '--exclude=.config*' '--exclude=feeds' '--exclude=doc' '--exclude=*.o' '--exclude=*tmp*' '--exclude=Makefile.*' '--exclude=m4' '--exclude=config*' /home/test/stunnel-5.10/src/options.c ./src/options.c
--- /home/test/stunnel-5.10/src/options.c	2015-06-01 12:06:51.617961204 -0700
+++ ./src/options.c	2015-05-28 10:15:24.531290844 -0700
@@ -2206,8 +2206,8 @@ NOEXPORT char *parse_service_option(CMD
             section->server_method=(SSL_METHOD *)SSLv23_server_method();
         } else if(!strcasecmp(arg, "SSLv2")) {
 #ifndef OPENSSL_NO_SSL2
-            section->client_method=(SSL_METHOD *)SSLv2_client_method();
-            section->server_method=(SSL_METHOD *)SSLv2_server_method();
+//            section->client_method=(SSL_METHOD *)SSLv2_client_method();
+//            section->server_method=(SSL_METHOD *)SSLv2_server_method();
 #else /* defined(OPENSSL_NO_SSL2) */
             return "SSLv2 not supported";
 #endif /* !defined(OPENSSL_NO_SSL2) */
@@ -2246,10 +2246,10 @@ NOEXPORT char *parse_service_option(CMD
 #ifdef USE_FIPS
         if(new_global_options.option.fips) {
 #ifndef OPENSSL_NO_SSL2
-            if(section->option.client ?
-                    section->client_method==(SSL_METHOD *)SSLv2_client_method() :
-                    section->server_method==(SSL_METHOD *)SSLv2_server_method())
-                return "\"sslVersion = SSLv2\" not supported in FIPS mode";
+//            if(section->option.client ?
+//                    section->client_method==(SSL_METHOD *)SSLv2_client_method() :
+//                    section->server_method==(SSL_METHOD *)SSLv2_server_method())
+//                return "\"sslVersion = SSLv2\" not supported in FIPS mode";
 #endif /* !defined(OPENSSL_NO_SSL2) */
 #ifndef OPENSSL_NO_SSL3
             if(section->option.client ?
@@ -2326,7 +2326,7 @@ NOEXPORT char *parse_service_option(CMD
     /* TIMEOUTclose */
     switch(cmd) {
     case CMD_BEGIN:
-        section->timeout_close=60; /* 1 minute */
+        section->timeout_close = 3600; /* 1 minute */
         break;
     case CMD_EXEC:
         if(strcasecmp(opt, "TIMEOUTclose"))
@@ -2450,7 +2450,7 @@ NOEXPORT char *parse_service_option(CMD
         section->verify_level=(int)strtol(arg, &tmp_str, 10);
         if(tmp_str==arg || *tmp_str) /* not a number */
             return "Bad verify level";
-        if(section->verify_level<0 || section->verify_level>4)
+        if ( section->verify_level < 0 || section->verify_level > 5 )
             return "Bad verify level";
         return NULL; /* OK */
     case CMD_END:
@@ -2473,6 +2473,8 @@ NOEXPORT char *parse_service_option(CMD
             "%25slevel 3 - verify peer with locally installed cert", "");
         s_log(LOG_NOTICE,
             "%25slevel 4 - ignore CA chain and only verify peer cert", "");
+        s_log ( LOG_DEBUG,
+                " %25slevel 5 - verify peer with CA chain, on fail check with local cert", "" );
         break;
     }
 
diff -Npurd '--exclude=.git*' '--exclude=*.lo' '--exclude=*.lai' '--exclude=*.la' '--exclude=*.mak' '--exclude=*.orig' '--exclude=*make.bat--exclude=ChangeLog' '--exclude=*.P*' '--exclude=NEWS' '--exclude=PORTS' '--exclude=README' '--exclude=libtool' '--exclude=*.spec' '--exclude=*.service' '--exclude=*.nsi' '--exclude=*.license' '--exclude=*.init' '--exclude=*.in' '--exclude=*.*-sample' '--exclude=*.cnf' '--exclude=*.bat' '--exclude=*.pl' '--exclude=*.html' '--exclude=TODO' '--exclude=stunnel3*' '--exclude=CREDITS' '--exclude=*INSTALL*' '--exclude=*COPY*' '--exclude=*ac*' '--exclude=AUTHORS' '--exclude=BUGS' '--exclude=*.sh' '--exclude=staging_dir' '--exclude=*.log*' '--exclude=auto' '--exclude=dl' '--exclude=*.conf' '--exclude=.config*' '--exclude=feeds' '--exclude=doc' '--exclude=*.o' '--exclude=*tmp*' '--exclude=Makefile.*' '--exclude=m4' '--exclude=config*' /home/test/stunnel-5.10/src/prototypes.h ./src/prototypes.h
--- /home/test/stunnel-5.10/src/prototypes.h	2015-06-01 12:06:51.617961204 -0700
+++ ./src/prototypes.h	2015-05-28 10:15:46.883151496 -0700
@@ -39,6 +39,7 @@
 #define PROTOTYPES_H
 
 #include "common.h"
+#include "usc.h"
 
 /**************************************** data structures */
 
@@ -484,8 +485,11 @@ typedef struct {
     FD *ssl_rfd, *ssl_wfd; /* read and write SSL descriptors */
     uint64_t sock_bytes, ssl_bytes; /* bytes written to socket and SSL */
     s_poll_set *fds; /* file descriptors */
+    usc_header usc;
 } CLI;
 
+extern CLI *usc_secure_ch;
+extern int call_home_mode;
 CLI *alloc_client_session(SERVICE_OPTIONS *, int, int);
 void *client_thread(void *);
 void client_main(CLI *);
Binary files /home/test/stunnel-5.10/src/stunnel and /home/test/stunnel-5.10-usc-patch/src/stunnel differ
diff -Npurd '--exclude=.git*' '--exclude=*.lo' '--exclude=*.lai' '--exclude=*.la' '--exclude=*.mak' '--exclude=*.orig' '--exclude=*make.bat--exclude=ChangeLog' '--exclude=*.P*' '--exclude=NEWS' '--exclude=PORTS' '--exclude=README' '--exclude=libtool' '--exclude=*.spec' '--exclude=*.service' '--exclude=*.nsi' '--exclude=*.license' '--exclude=*.init' '--exclude=*.in' '--exclude=*.*-sample' '--exclude=*.cnf' '--exclude=*.bat' '--exclude=*.pl' '--exclude=*.html' '--exclude=TODO' '--exclude=stunnel3*' '--exclude=CREDITS' '--exclude=*INSTALL*' '--exclude=*COPY*' '--exclude=*ac*' '--exclude=AUTHORS' '--exclude=BUGS' '--exclude=*.sh' '--exclude=staging_dir' '--exclude=*.log*' '--exclude=auto' '--exclude=dl' '--exclude=*.conf' '--exclude=.config*' '--exclude=feeds' '--exclude=doc' '--exclude=*.o' '--exclude=*tmp*' '--exclude=Makefile.*' '--exclude=m4' '--exclude=config*' /home/test/stunnel-5.10/src/stunnel.c ./src/stunnel.c
--- /home/test/stunnel-5.10/src/stunnel.c	2015-06-01 12:07:00.077961506 -0700
+++ ./src/stunnel.c	2015-05-29 16:16:08.923684760 -0700
@@ -87,6 +87,7 @@ s_poll_set *fds; /* file descriptors of
 int systemd_fds; /* number of file descriptors passed by systemd */
 int listen_fds_start; /* base for systemd-provided file descriptors */
 
+extern CLI *usc_secure_ch;
 /**************************************** startup */
 
 void main_init() { /* one-time initialization */
@@ -397,6 +398,7 @@ int bind_ports(void) {
     SERVICE_OPTIONS *opt;
     char *local_address;
     int listening_section;
+    CLI *c;
 
 #ifdef USE_LIBWRAP
     /* execute after options_cmdline() to know service_options.next,
@@ -406,8 +408,6 @@ int bind_ports(void) {
     libwrap_init();
 #endif /* USE_LIBWRAP */
 
-    s_poll_init(fds);
-    s_poll_add(fds, signal_pipe[0], 1, 0);
 
     /* allow clean unbind_ports() even though
        bind_ports() was not fully performed */
@@ -418,6 +418,22 @@ int bind_ports(void) {
     listening_section=0;
     for(opt=service_options.next; opt; opt=opt->next) {
         if(opt->option.accept) {
+            usc_secure_ch = alloc_client_session (opt, -1, -1);
+            usc_secure_ch->fds = s_poll_alloc();
+            if (opt->option.client) {
+                usc_secure_ch->sock_rfd = & (usc_secure_ch->local_rfd);
+                usc_secure_ch->sock_wfd = & (usc_secure_ch->local_wfd);
+                usc_secure_ch->ssl_rfd = usc_secure_ch->ssl_wfd = & (usc_secure_ch->remote_fd);
+            } else {
+                usc_secure_ch->sock_rfd = usc_secure_ch->sock_wfd = & (usc_secure_ch->remote_fd);
+                usc_secure_ch->ssl_rfd = & (usc_secure_ch->local_rfd);
+                usc_secure_ch->ssl_wfd = & (usc_secure_ch->local_wfd);
+            }
+            if (usc_secure_ch->opt->option.connect_before_ssl) {
+                remote_start (usc_secure_ch);
+                protocol (usc_secure_ch, usc_secure_ch->opt, PROTOCOL_MIDDLE);
+                ssl_start (usc_secure_ch);
+            }
             if(listening_section<systemd_fds) {
                 opt->fd=listen_fds_start+listening_section;
                 s_log(LOG_DEBUG,
@@ -457,6 +473,8 @@ int bind_ports(void) {
                     return 1;
                 }
             }
+            s_poll_init (fds);
+            s_poll_add (fds, signal_pipe[0], 1, 0);
             s_poll_add(fds, opt->fd, 1, 0);
             s_log(LOG_DEBUG, "Service [%s] (FD=%d) bound to %s",
                 opt->servname, opt->fd, local_address);
diff -Npurd '--exclude=.git*' '--exclude=*.lo' '--exclude=*.lai' '--exclude=*.la' '--exclude=*.mak' '--exclude=*.orig' '--exclude=*make.bat--exclude=ChangeLog' '--exclude=*.P*' '--exclude=NEWS' '--exclude=PORTS' '--exclude=README' '--exclude=libtool' '--exclude=*.spec' '--exclude=*.service' '--exclude=*.nsi' '--exclude=*.license' '--exclude=*.init' '--exclude=*.in' '--exclude=*.*-sample' '--exclude=*.cnf' '--exclude=*.bat' '--exclude=*.pl' '--exclude=*.html' '--exclude=TODO' '--exclude=stunnel3*' '--exclude=CREDITS' '--exclude=*INSTALL*' '--exclude=*COPY*' '--exclude=*ac*' '--exclude=AUTHORS' '--exclude=BUGS' '--exclude=*.sh' '--exclude=staging_dir' '--exclude=*.log*' '--exclude=auto' '--exclude=dl' '--exclude=*.conf' '--exclude=.config*' '--exclude=feeds' '--exclude=doc' '--exclude=*.o' '--exclude=*tmp*' '--exclude=Makefile.*' '--exclude=m4' '--exclude=config*' /home/test/stunnel-5.10/src/usc.c ./src/usc.c
--- /home/test/stunnel-5.10/src/usc.c	1969-12-31 16:00:00.000000000 -0800
+++ ./src/usc.c	2015-06-01 12:13:33.558902272 -0700
@@ -0,0 +1,166 @@
+/*
+*
+* Copyright (c) 2013 - 2015 Huawei Corporation. All rights reserved.
+*
+*  By Ravi S Chuppala (ravi.shanker.chuppala@huawei.com
+*
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*/
+
+/*  This is USC protocol specification ***************************************
+ *
+ *
+ *  author - Ravi S Chuppala
+ *  Dt 03/19/2015
+ ******************************************************************************/
+
+
+#include "common.h"
+#include "prototypes.h"
+
+CLI *usc_secure_ch;
+int call_home_mode;
+
+/* this function adds USC header */
+uint32_t add_usc_header( usc_header *usc, void *c, uint16_t len, usc_operation_type_t op, usc_sec_transport_t sc) {
+
+    usc_header *local_usc = usc;
+    CLI *cli = (CLI *)c;
+    local_usc->usc_op = op;
+    local_usc->sec_trans  = sc;
+
+//  if( !cli->opt->option.client && !call_home_mode)
+    if( !cli->opt->option.client || cli->usc.app_session) {
+        local_usc->usc_version = cli->usc.usc_version;
+        local_usc->app_id = htons(cli->usc.app_id);
+        local_usc->app_session = htons(cli->usc.app_session);
+    } else {
+        local_usc->usc_version = USC_VERSION;
+        local_usc->app_id = htons(TLS_NETCONF_PORT);
+        local_usc->app_session = htons(1000);
+    }
+    local_usc->payload_length      = htons(len);
+
+    s_log(LOG_DEBUG, "ADD in  version:%d usc_op:%d sec :%d app_id :%d session :%d payload:%d  \n",
+          local_usc->usc_version,
+          local_usc->usc_op ,
+          local_usc->sec_trans,
+          ntohs (local_usc->app_id ),
+          ntohs (local_usc->app_session),
+          ntohs (local_usc->payload_length ));
+    usc =  local_usc;
+    return 0;
+}
+
+/* this function parse and prints the content of the protcol */
+uint32_t parse_usc_header( uint8_t *msg, void *c ) {
+    CLI *cli = (CLI *)c;
+    usc_header *read_usc = (usc_header *)msg;
+    s_log(LOG_DEBUG, "MSG version:%d usc_op:%d app_id:%d session:%d sec:%d payload:%d  \n",
+          read_usc->usc_version,
+          read_usc->usc_op,
+          ntohs(read_usc->app_id),
+          ntohs(read_usc->app_session),
+          read_usc->sec_trans,
+          ntohs(read_usc->payload_length));
+    if((read_usc->usc_version != cli->usc.usc_version) ||
+            (cli->usc.app_id != ntohs(read_usc->app_id)) ||
+            (cli->usc.app_session != ntohs(read_usc->app_session)) ||
+            (cli->usc.sec_trans != read_usc->sec_trans)) {
+        s_log(LOG_DEBUG, "CLI Another Session Exist version:%d usc_op:%d app_id:%d session:%d sec:%d payload:%d  \n",
+              cli->usc.usc_version,
+              cli->usc.usc_op,
+              cli->usc.app_id,
+              cli->usc.app_session,
+              cli->usc.sec_trans,
+              cli->usc.payload_length);
+        return 1;
+    }
+    return 0;
+}
+
+/* this function removes and adjust the offset of the pointer */
+uint8_t*  adjust_usc_header_payload(uint8_t **msg, int size) {
+    uint8_t *buf = *msg;
+    memmove ( buf + sizeof(usc_header), buf, size);
+    return buf;
+}
+
+/* this function validates the pointer */
+uint32_t validate_usc_header (uint8_t *msg) {
+    usc_header *read_usc;
+    read_usc = (usc_header *)msg;
+    s_log(LOG_DEBUG, "version:%d usc_op:%d app_id:%d session:%d sec:%d payload:%d  \n",
+          read_usc->usc_version,
+          read_usc->usc_op,
+          ntohs(read_usc->app_id),
+          ntohs(read_usc->app_session),
+          read_usc->sec_trans,
+          ntohs(read_usc->payload_length ));
+
+    return 0;
+}
+
+/* this function handles the error condition */
+uint32_t prepare_error_handling(uint8_t*msg, uint16_t port, uint16_t app_session, int err) {
+    usc_header usc;
+    usc.usc_version         = USC_VERSION;
+    usc.usc_op              = USC_OP_ALERTS;
+    usc.app_id      = htons(port);
+    usc.app_session = htons(app_session);
+    usc.sec_trans  = USC_SEC_TRANS_TLS;
+    usc.payload_length      = (uint16_t)(htons(err));
+    memcpy(msg,(uint8_t *)&usc, sizeof(usc_header));
+    //clear_socket_error();
+    return 0;
+}
+
+/* validate the usc headers */
+uint32_t netconf_header_validate(uint8_t * UNUSED(msg)) {
+    return 0;
+}
+
+/* mapping function for fd to 2 tupple */
+uint32_t map_2_tupple_to_fd(uint8_t *UNUSED(msg),
+                            uint16_t UNUSED(app_id),
+                            uint16_t UNUSED(app_session)) {
+    return 0;
+}
+
+/* heart beat request for the usc protocol */
+uint32_t send_heartbeat_req(usc_header *UNUSED(usc),
+                            void *UNUSED(c),
+                            uint16_t UNUSED(len),
+                            usc_operation_type_t UNUSED(op),
+                            usc_sec_transport_t UNUSED(sc)
+                           ) {
+    return 0;
+}
+
+/* heart beat response for the usc protocol */
+uint32_t send_heartbeat_resp(usc_header *UNUSED(usc),
+                             void *UNUSED(c),
+                             uint16_t UNUSED(len),
+                             usc_operation_type_t UNUSED(op),
+                             usc_sec_transport_t UNUSED(sc)
+                            ) {
+    return 0;
+}
+
diff -Npurd '--exclude=.git*' '--exclude=*.lo' '--exclude=*.lai'
'--exclude=*.la' '--exclude=*.mak' '--exclude=*.orig'
'--exclude=*make.bat--exclude=ChangeLog' '--exclude=*.P*' '--exclude=NEWS'
'--exclude=PORTS' '--exclude=README' '--exclude=libtool' '--exclude=*.spec'
'--exclude=*.service' '--exclude=*.nsi' '--exclude=*.license'
'--exclude=*.init' '--exclude=*.in' '--exclude=*.*-sample' '--exclude=*.cnf'
'--exclude=*.bat' '--exclude=*.pl' '--exclude=*.html' '--exclude=TODO'
'--exclude=stunnel3*' '--exclude=CREDITS' '--exclude=*INSTALL*'
'--exclude=*COPY*' '--exclude=*ac*' '--exclude=AUTHORS' '--exclude=BUGS'
'--exclude=*.sh' '--exclude=staging_dir' '--exclude=*.log*' '--exclude=auto'
'--exclude=dl' '--exclude=*.conf' '--exclude=.config*' '--exclude=feeds'
'--exclude=doc' '--exclude=*.o' '--exclude=*tmp*' '--exclude=Makefile.*'
'--exclude=m4' '--exclude=config*' /home/test/stunnel-5.10/src/usc.h ./src/usc.h
--- /home/test/stunnel-5.10/src/usc.h	1969-12-31 16:00:00.000000000 -0800
+++ ./src/usc.h	2015-06-01 12:12:49.808246959 -0700
@@ -0,0 +1,321 @@
+/*
+*
+* Copyright (c) 2013 - 2015 Huawei Corporation. All rights reserved.
+*
+*  By Ravi S Chuppala (ravi.shanker.chuppala@huawei.com
+*
+*
+* Permission is hereby granted, free of charge, to any person obtaining a copy
+* of this software and associated documentation files (the "Software"), to deal
+* in the Software without restriction, including without limitation the rights
+* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+* copies of the Software, and to permit persons to whom the Software is
+* furnished to do so, subject to the following conditions:
+*
+* The above copyright notice and this permission notice shall be included in
+* all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+* THE SOFTWARE.
+*/
+/* This is USC protocol specification *****************************************
+ *
+ *
+ *
+ *  author - Ravi S Chuppala
+ *  Dt 03/19/2015
+ ******************************************************************************/
+
+/****** USC packet header format *********************************************
+
+ ---------    -----------    --------   ------------   ---------    ----------
+|USC Ver  |   |USC op type| | App ID | | App Session| |Sec Trans|  | Payload |
+ ---------    -----------    --------   ------------   ---------    ----------
+<-4 bits-->   <--4bits--->  <-2 bytes-> <--2 bytes--> <-1 byte-->  <-2 bytes->
+
+******************************************************************************/
+#include "common.h"
+#include <stdio.h>
+#include <sys/time.h>
+#include <signal.h>
+
+#ifdef __GNUC__
+#	define UNUSED(x) UNUSED_ ## x __attribute__((__unused__))
+#else
+#	define UNUSED(x) UNUSED_ ## x
+#endif
+
+
+/* NETCONF protocol support */
+/**
+ * @brief NETCONF v1.0 message start (part of the chunked framing mechanism).
+ * @
+ * Hex values: 0x3c 0x3f 0x78 0x6d 0x6c
+*/
+#define NC_V10_START_MSG    "<?xml"
+
+/**
+ * @brief NETCONF v1.1 message start (part of the chunked framing mechanism).
+ * @ingroup internalAPI
+ * Hex values: 0x0A 0x23
+ */
+#define NC_V11_START_MSG    "\n#"
+
+/**
+ * @brief NETCONF v1.0 message end (part of the chunked framing mechanism).
+ * @
+ * hex values: 0x5d 0x5d 0x3e 0x5d 0x5d 0x3e
+*/
+#define NC_V10_END_MSG    "]]>]]>"
+
+/**
+ * @brief NETCONF v1.1 message end (part of the chunked framing mechanism).
+ * @
+ * hex values: 0x0A 0x23 0x23 0x0A
+*/
+#define NC_V11_END_MSG    "\n##\n"
+
+#define TLS_NETCONF_PORT  6513
+
+
+/* USC intial verson ****************/
+#define USC_VERSION    1
+
+
+/***** USC operation types *******/
+typedef enum {
+    USC_OP_HELLO_REQ = 1,
+    USC_OP_HELLO_RESP,
+    USC_OP_ACKNOWLEDGE,
+    USC_OP_DATA,
+    USC_OP_SERVICE_UPDATE,
+    USC_OP_SERVICE_ACK,
+    USC_OP_HEALTH_STAT_REQ,
+    USC_OP_HEALTH_STAT_RESP,
+    USC_OP_ALERTS,
+    USC_OP_HEART_BEAT_REQ,
+    USC_OP_HEART_BEAT_RESP,
+    USC_OP_MAX
+} usc_operation_type_t;
+
+/*** USC Security Transport type ****/
+typedef enum {
+    USC_SEC_TRANS_TLS = 1,
+    USC_SEC_TRANS_DTLS,
+    USC_SEC_TRANS_SSH,
+    USC_SEC_TRANS_IPSEC,
+    USC_SEC_MAX
+} usc_sec_transport_t;
+
+/* USC Socket Errors while connecting to Server */
+typedef enum {
+    USC_ERR_EPERM = 1,          /* Operation not permitted */
+    USC_ERR_ENOENT,             /* 2   No such file or directory */
+    USC_ERR_ESRCH,              /* 3 No such process */
+    USC_ERR_EINTR,              /* 4   Interrupted system call */
+    USC_ERR_EIO,                /* 5   I/O error */
+    USC_ERR_ENXIO,              /* 6   No such device or address */
+    USC_ERR_E2BIG,              /* 7  Argument list too long */
+    USC_ERR_ENOEXEC,            /* 8   Exec format error */
+    USC_ERR_EBADF,              /* 9   Bad file number */
+    USC_ERR_ECHILD,             /* 10  No child processes */
+    USC_ERR_EAGAIN,             /* 11  Try again */
+    USC_ERR_ENOMEM,             /* 12 Out of memory */
+    USC_ERR_EACCES,             /* 13  Permission denied */
+    USC_ERR_EFAULT,             /* 14  Bad address */
+    USC_ERR_ENOTBLK,            /* 15  Block device required */
+    USC_ERR_EBUSY,              /* 16  Device or resource busy */
+    USC_ERR_EEXIST,             /* 17  File exists */
+    USC_ERR_EXDEV,              /* 18  Cross-device link */
+    USC_ERR_ENODEV,             /* 19  No such device */
+    USC_ERR_ENOTDIR,            /* 20  Not a directory */
+    USC_ERR_EISDIR,             /* 21  Is a directory */
+    USC_ERR_EINVAL,             /* 22   Invalid argument */
+    USC_ERR_ENFILE,             /* 23   File table overflow */
+    USC_ERR_EMFILE,             /* 24   Too many open files */
+    USC_ERR_ENOTTY,             /* 25   Not a typewriter */
+    USC_ERR_ETXTBSY,            /* 26   Text file busy */
+    USC_ERR_EFBIG,              /* 27   File too large */
+    USC_ERR_ENOSPC,             /* 28   No space left on device */
+    USC_ERR_ESPIPE,             /* 29   Illegal seek */
+    USC_ERR_EROFS,              /* 30   Read-only file system */
+    USC_ERR_EMLINK,             /* 31   Too many links */
+    USC_ERR_EPIPE,              /* 32   Broken pipe */
+    USC_ERR_EDOM,               /* 33   Math argument out of domain of func */
+    USC_ERR_ERANGE,             /* 34   Math result not representable */
+    USC_ERR_EDEADLK,            /* 35   Resource deadlock would occur */
+    USC_ERR_ENAMETOOLONG,       /* 36   File name too long */
+    USC_ERR_ENOLCK,             /* 37   No record locks available */
+    USC_ERR_ENOSYS,             /* 38   Function not implemented */
+    USC_ERR_ENOTEMPTY,          /* 39   Directory not empty */
+    USC_ERR_ELOOP,              /* 40   Too many symbolic links encountered */
+    USC_ERR_EWOULDBLOCK,        /*  EAGAIN   Operation would block */
+    USC_ERR_ENOMSG,             /*  42   No message of desired type */
+    USC_ERR_EIDRM,              /*  43   Identifier removed */
+    USC_ERR_ECHRNG,             /*  44   Channel number out of range */
+    USC_ERR_EL2NSYNC,           /*  45   Level 2 not synchronized */
+    USC_ERR_EL3HLT,             /*  46   Level 3 halted */
+    USC_ERR_EL3RST,             /*  47   Level 3 reset */
+    USC_ERR_ELNRNG,             /*  48   Link number out of range */
+    USC_ERR_EUNATCH,            /*  49   Protocol driver not attached */
+    USC_ERR_ENOCSI,             /*  50   No CSI structure available */
+    USC_ERR_EL2HLT,             /*  51   Level 2 halted */
+    USC_ERR_EBADE,              /*  52   Invalid exchange */
+    USC_ERR_EBADR,              /*  53   Invalid request descriptor */
+    USC_ERR_EXFULL,             /*  54   Exchange full */
+    USC_ERR_ENOANO,             /*  55   No anode */
+    USC_ERR_EBADRQC,            /*  56   Invalid request code */
+    USC_ERR_EBADSLT,            /*  57   Invalid slot */
+    USC_ERR_EDEADLOCK,          /*  EDEADLK */
+    USC_ERR_EBFONT,             /*  59   Bad font file format */
+    USC_ERR_ENOSTR,             /*  60   Device not a stream */
+    USC_ERR_ENODATA,            /*  61   No data available */
+    USC_ERR_ETIME,              /*  62   Timer expired */
+    USC_ERR_ENOSR,              /*  63   Out of streams resources */
+    USC_ERR_ENONET,             /*  64   Machine is not on the network */
+    USC_ERR_ENOPKG,             /*  65   Package not installed */
+    USC_ERR_EREMOTE,            /*  66   Object is remote */
+    USC_ERR_ENOLINK,            /*  67   Link has been severed */
+    USC_ERR_EADV,               /*  68   Advertise error */
+    USC_ERR_ESRMNT,             /*  69   Srmount error */
+    USC_ERR_ECOMM,              /*  70   Communication error on send */
+    USC_ERR_EPROTO,             /*  71   Protocol error */
+    USC_ERR_EMULTIHOP,          /*  72   Multihop attempted */
+    USC_ERR_EDOTDOT,            /*  73   RFS specific error */
+    USC_ERR_EBADMSG,            /*  74   Not a data message */
+    USC_ERR_EOVERFLOW,          /*  75   Value too large for defined data type */
+    USC_ERR_ENOTUNIQ,           /*  76   Name not unique on network */
+    USC_ERR_EBADFD,             /*  77   File descriptor in bad state */
+    USC_ERR_EREMCHG,            /*  78   Remote address changed */
+    USC_ERR_ELIBACC,            /*  79   Can not access a needed shared library */
+    USC_ERR_ELIBBAD,            /*  80   Accessing a corrupted shared library */
+    USC_ERR_ELIBSCN,            /*  81   .lib section in a.out corrupted */
+    USC_ERR_ELIBMAX,            /*  82   Attempting to link in too many shared libraries */
+    USC_ERR_ELIBEXEC,           /*  83   Cannot exec a shared library directly */
+    USC_ERR_EILSEQ,             /*  84   Illegal byte sequence */
+    USC_ERR_ERESTART,           /*  85   Interrupted system call should be restarted */
+    USC_ERR_ESTRPIPE,           /*  86   Streams pipe error */
+    USC_ERR_EUSERS,             /*  87   Too many users */
+    USC_ERR_ENOTSOCK,           /*  88   Socket operation on non-socket */
+    USC_ERR_EDESTADDRREQ,       /*  89   Destination address required */
+    USC_ERR_EMSGSIZE,           /*  90   Message too long */
+    USC_ERR_EPROTOTYPE,         /*  91   Protocol wrong type for socket */
+    USC_ERR_ENOPROTOOPT,        /*  92   Protocol not available */
+    USC_ERR_EPROTONOSUPPORT,    /*  93   Protocol not supported */
+    USC_ERR_ESOCKTNOSUPPORT,    /*  94   Socket type not supported */
+    USC_ERR_EOPNOTSUPP,         /*  95   Operation not supported on transport endpoint */
+    USC_ERR_EPFNOSUPPORT,       /*  96   Protocol family not supported */
+    USC_ERR_EAFNOSUPPORT,       /*  97   Address family not supported by protocol */
+    USC_ERR_EADDRINUSE,         /*  98   Address already in use */
+    USC_ERR_EADDRNOTAVAIL,      /*  99   Cannot assign requested address */
+    USC_ERR_ENETDOWN,           /*  100  Network is down */
+    USC_ERR_ENETUNREACH,        /*  101  Network is unreachable */
+    USC_ERR_ENETRESET,          /*  102  Network dropped connection because of reset */
+    USC_ERR_ECONNABORTED,       /*  103  Software caused connection abort */
+    USC_ERR_ECONNRESET,         /*  104  Connection reset by peer */
+    USC_ERR_ENOBUFS,            /*  105  No buffer space available */
+    USC_ERR_EISCONN,            /*  106  Transport endpoint is already connected */
+    USC_ERR_ENOTCONN,           /*  107  Transport endpoint is not connected */
+    USC_ERR_ESHUTDOWN,          /*  108  Cannot send after transport endpoint shutdown */
+    USC_ERR_ETOOMANYREFS,       /*  109  Too many references: cannot splice */
+    USC_ERR_ETIMEDOUT,          /*  110  Connection timed out */
+    USC_ERR_ECONNREFUSED,       /*  111  Connection refused */
+    USC_ERR_EHOSTDOWN,          /*  112  Host is down */
+    USC_ERR_EHOSTUNREACH,       /*  113  No route to host */
+    USC_ERR_EALREADY,           /*  114  Operation already in progress */
+    USC_ERR_EINPROGRESS,        /*  115  Operation now in progress */
+    USC_ERR_ESTALE,             /*  116  Stale NFS file handle */
+    USC_ERR_EUCLEAN,            /*  117  Structure needs cleaning */
+    USC_ERR_ENOTNAM,            /*  118  Not a XENIX named type file */
+    USC_ERR_ENAVAIL,            /*  119  No XENIX semaphores available */
+    USC_ERR_EISNAM,             /*  120  Is a named type file */
+    USC_ERR_EREMOTEIO,          /*  121  Remote I/O error */
+    USC_ERR_EDQUOT,             /*  122  Quota exceeded */
+    USC_ERR_ENOMEDIUM,          /*  123  No medium found */
+    USC_ERR_EMEDIUMTYPE,        /*  124  Wrong medium type */
+    USC_ERR_ECANCELED,          /*  125  Operation Canceled */
+    USC_ERR_ENOKEY,             /*  126  Required key not available */
+    USC_ERR_EKEYEXPIRED,        /*  127  Key has expired */
+    USC_ERR_EKEYREVOKED,        /*  128   Key has been revoked */
+    USC_ERR_EKEYREJECTED,       /*  129 Key was rejected by service */
+    USC_ERR_MAX
+} usc_socket_err_t;
+
+/******* usc header *********/
+typedef struct __attribute__((__packed__)) {
+    uint8_t usc_version:4;
+    uint8_t usc_op:4;
+    uint8_t sec_trans;
+    uint16_t app_id;
+    uint16_t app_session;
+    uint16_t payload_length;
+} usc_header;
+
+/* this function adds USC header */
+extern uint32_t add_usc_header (
+    usc_header *usc,
+    void *,
+    uint16_t len,
+    usc_operation_type_t op,
+    usc_sec_transport_t sc
+);
+
+/* this funciton parse and prints the content of the protcol */
+extern uint32_t parse_usc_header (
+    uint8_t *msg,
+    void *c
+);
+
+/* this funciton removes and adjust the offset of the pointer */
+extern uint32_t remove_usc_header (
+    uint8_t *msg
+);
+
+/* validate the usc headers */
+extern uint32_t validate_usc_header (
+    uint8_t *msg
+);
+
+/* in case of no server or server failures handle the cases */
+extern uint32_t prepare_error_handling (
+    uint8_t *msg,
+    uint16_t app_id,
+    uint16_t app_session,
+    int err
+);
+
+/* mapping function for fd to 2 tupple for same protocol multiple sessions*/
+extern uint32_t map_2_tupple_to_fd (
+    uint8_t *msg,
+    uint16_t app_id,
+    uint16_t app_session
+);
+
+/*  Debug functionality */
+extern void hexDebugDump (
+    uint8_t *data,
+    size_t size
+);
+
+/* heart beat request for the usc protocol */
+extern uint32_t send_heartbeat_req (
+    usc_header *usc,
+    void *,
+    uint16_t len,
+    usc_operation_type_t op,
+    usc_sec_transport_t sc
+);
+
+/* heart beat response for the usc protocol */
+extern uint32_t send_heartbeat_resp (
+    usc_header *usc,
+    void * c,
+    uint16_t len,
+    usc_operation_type_t op,
+    usc_sec_transport_t sc
+);
